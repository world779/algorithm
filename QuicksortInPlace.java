//*今回は、配列a,b,cがある中で、配列aを選んだ
//*1.一番初めの値a[low]=3を基準とする
//*2.変数i への代入  i = 0
//*3.変数j への代入  j = 9
//*4.配列要素と基準値の比較  a[0] = 3  ==  x = 3   同値 true
//*4.配列要素と基準値の比較  a[9] = 5  <  x = 3   false
//*3.変数j への代入  j = 8
//*4.配列要素と基準値の比較  a[8] = 0  >  x = 3   true
//*5.配列要素の交換  a[0] = 3   と   a[8] = 0

//*2.変数i への代入  i = 1
//*3.変数j への代入  j = 7
//*4.配列要素と基準値の比較  a[1] = 6  >  x = 3  true
//*4.配列要素と基準値の比較  a[7] = 2  <  x = 3  true
//*5.配列要素の交換  a[1] = 6   と   a[7] = 2

//*2.変数i への代入  i = 2
//*3.変数j への代入  j = 6
//*4.配列要素と基準値の比較  a[2] = 8  >  x = 3  true
//*4.配列要素と基準値の比較  a[6] = 4  >  x = 3  false
//*3.変数j への代入  j = 5
//*4.配列要素と基準値の比較  a[5] = 7  >  x = 3  false
//*3.変数j への代入  j = 4
//*4.配列要素と基準値の比較  a[4] = 9  >  x = 3  false
//*3.変数j への代入  j = 3
//*4.配列要素と基準値の比較  a[3] = 1  <  x = 3  true
//*5.配列要素の交換  a[2] = 8   と   a[3] = 1

//*2.変数i への代入  i = 3
//*3.変数j への代入  j = 2
//*6.分割の終了 a = {0, 2, 1, 8, 9, 7, 4, 6, 3, 5}   i = 3, j = 2


//*1.一番初めの値a[low]=0を基準とする
//*2.変数i への代入  i = 0
//*3.変数j への代入  j = 2
//*4.配列要素と基準値の比較  a[0] = 0  ==  x = 0   同値 true
//*4.配列要素と基準値の比較  a[2] = 1  >  x = 0   false
//*3.変数j への代入  j = 1
//*4.配列要素と基準値の比較  a[1] = 2  >  x = 0   false
//*3.変数j への代入  j = 0
//*4.配列要素と基準値の比較  a[0] = 0  ==  x = 0   同値 true
//*5.配列要素の交換  a[0] = 0   と   a[0] = 0

//*2.変数i への代入  i = 1
//*3.変数j への代入  j = -1
//*6.分割の終了 a = {0, 2, 1}   i = 1, j = -1


//*.一番初めの値a[low]=2を基準とする
//*2.変数i への代入  i = 0
//*3.変数j への代入  j = 1
//*4.配列要素と基準値の比較  a[0] = 2  ==  x = 2   同値 true
//*4.配列要素と基準値の比較  a[1] = 1  <  x = 2   true
//*5.配列要素の交換  a[0] = 2   と   a[1] = 1

//*2.変数i への代入  i = 1
//*3.変数j への代入  j = 0
//*6.分割の終了 a = {1, 2}   i = 1, j = 0



//*1.一番初めの値a[low]=8を基準とする
//*2.変数i への代入  i = 0
//*3.変数j への代入  j = 6
//*4.配列要素と基準値の比較  a[0] = 8  ==  x = 8   同値 true
//*4.配列要素と基準値の比較  a[6] = 5  <  x = 8   true
//*5.配列要素の交換  a[0] = 8   と   a[6] = 5

//*2.変数i への代入  i = 1
//*3.変数j への代入  j = 5
//*4.配列要素と基準値の比較  a[1] = 9  >  x = 8   true
//*4.配列要素と基準値の比較  a[5] = 3  <  x = 8   true
//*5.配列要素の交換  a[1] = 9   と   a[5] = 3

//*2.変数i への代入  i = 2
//*3.変数j への代入  j = 4
//*4.配列要素と基準値の比較  a[2] = 7  <  x = 8   false
//*2.変数i への代入  i = 3
//*4.配列要素と基準値の比較  a[3] = 4  <  x = 8   false
//*2.変数i への代入  i = 4
//*4.配列要素と基準値の比較  a[4] = 6  <  x = 8   false
//*2.変数i への代入  i = 5
//*6.分割の終了 a = {5, 3, 7, 4, 6, 9, 8}   i = 5, j = 4


//*1.一番初めの値a[low]=5を基準とする
//*2.変数i への代入  i = 0
//*3.変数j への代入  j = 4
//*4.配列要素と基準値の比較  a[0] = 5  ==  x = 5   同値 true
//*4.配列要素と基準値の比較  a[4] = 6  >  x = 5   false
//*3.変数j への代入  j = 3
//*4.配列要素と基準値の比較  a[3] = 4  <  x = 5   true
//*5.配列要素の交換  a[0] = 5   と   a[3] = 4

//*2.変数i への代入  i = 1
//*3.変数j への代入  j = 2
//*4.配列要素と基準値の比較  a[1] = 3  <  x = 5   false
//*2.変数i への代入  i = 2
//*4.配列要素と基準値の比較  a[2] = 7  >  x = 5   true
//*4.配列要素と基準値の比較  a[2] = 7  >  x = 5   false
//*3.変数j への代入  j = 1
//*6.分割の終了 a = {4, 3, 7, 5, 6}   i = 2, j = 1

//*1.一番初めの値a[low]=4を基準とする
//*2.変数i への代入  i = 0
//*3.変数j への代入  j = 1
//*4.配列要素と基準値の比較  a[0] = 4  ==  x = 4   同値 true
//*4.配列要素と基準値の比較  a[1] = 3  <  x = 4   true
//*5.配列要素の交換  a[0] = 5   と   a[1] = 3

//*2.変数i への代入  i = 1
//*3.変数j への代入  j = 0
//*6.分割の終了 a = {3, 4}   i = 1, j = 0

//*1.一番初めの値a[low]=7を基準とする
//*2.変数i への代入  i = 0
//*3.変数j への代入  j = 2
//*4.配列要素と基準値の比較  a[0] = 7  ==  x = 7   同値 true
//*4.配列要素と基準値の比較  a[2] = 6  <  x = 7   true
//*5.配列要素の交換  a[0] = 7   と   a[2] = 6

//*2.変数i への代入  i = 1
//*3.変数j への代入  j = 1
//*4.配列要素と基準値の比較  a[1] = 5  <  x = 7   false
//*2.変数i への代入  i = 2
//*4.配列要素と基準値の比較  a[1] = 5  <  x = 7   true
//*6.分割の終了 a = {6, 5, 7}   i = 2, j = 1


//*1.一番初めの値a[low]=6を基準とする
//*2.変数i への代入  i = 0
//*3.変数j への代入  j = 1
//*4.配列要素と基準値の比較  a[0] = 6  ==  x = 6   同値 true
//*4.配列要素と基準値の比較  a[1] = 5  <  x = 6   true
//*5.配列要素の交換  a[0] = 6   と   a[1] = 5

//*2.変数i への代入  i = 1
//*3.変数j への代入  j = 0
//*6.分割の終了 a = {5, 6}   i = 1, j = 0


//*1.一番初めの値a[low]=9を基準とする
//*2.変数i への代入  i = 0
//*3.変数j への代入  j = 1
//*4.配列要素と基準値の比較  a[0] = 9  ==  x = 9   同値 true
//*4.配列要素と基準値の比較  a[1] = 8  <  x = 9   true
//*5.配列要素の交換  a[0] = 9   と   a[1] = 8

//*2.変数i への代入  i = 1
//*3.変数j への代入  j = 0
//*6.分割の終了 a = {8, 9}   i = 1, j = 0







package task06;

public class QuicksortInPlace {
	public static void main(String[] args)	{

		//*int型の配列a,b,cを用意し、初期化する
		int [] a = {3, 6, 8, 1, 9, 7, 4, 2, 0, 5};
		int [] b = {9, 2, 3, 5, 1, 5, 3, 4, 7, 2};
		int [] c = {1, 6, 0, 4, 7, 5, 3, 9, 2, 8};

		//*今回、sort関数では配列の中で一番初めの値を基準値としているため、最大の値を基準値としても
		//*プログラムが正しく機能しているかどうかを確認できるよう、配列bの一番初めの値に最大値を用意した

		//*用意した配列の内容をそれぞれ出力する
		//*配列の要素は1桁とは限らないため、要素それぞれに空白も加える
		System.out.print("a = ");
		for (int i = 0; i < 10; i++)
			System.out.print(a[i] + " ");
		System.out.println();
		System.out.print("b = ");
		for (int i = 0; i < 10; i++)
			System.out.print(b[i] + " ");
		System.out.println();
		System.out.print("c = ");
		for (int i = 0; i < 10; i++)
			System.out.print(c[i] + " ");
		System.out.println();
		System.out.println();

		//*sortを呼び出して整列する
		sort(a,10);
		sort(b,10);
		sort(c,10);

		//*整列させた配列をそれぞれ出力する
		System.out.print("a = ");
		for (int i = 0; i < 10; i++)
			System.out.print(a[i] + " ");
		System.out.println();
		System.out.print("b = ");
		for (int i = 0; i < 10; i++)
			System.out.print(b[i] + " ");
		System.out.println();
		System.out.print("c = ");
		for (int i = 0; i < 10; i++)
			System.out.print(c[i] + " ");
		System.out.println();

	}

	//*main関数から簡単に呼び出せるように、引数の少ない関数をここで定義する
	//*Java では同じメソッド名でも、引数リストが異なれば異なるメソッドとして区別される
	private static void sort(int a[], int n) {
	sort(a,0,n-1);
}

	//*ここでは、再帰メゾットを定義する。
	private static void sort(int a[], int low, int high) {
		int i, j, w;

		//*分割の基準となる値を決める
		//*ここでは、aの配列の中にある値としてaの配列の一番初めの値を用いる
		int x = a[low];

		//*要素が1以下だったとき、再帰呼び出しを止める。
		//*これをしないと、無限再帰に陥る可能性がある
		if(high-low <= 0) return;

		i = low;
		j = high;

		//*ここで、前からと後ろからで値を見て行って、iは右側に行ってもよい、
		//*jは左側に行ってもよいとする
		//*その中で、基準値よりa[i]が大きい、基準値がa[j]より小さければ、
		//*その二つの値を入れ替える
		while(i <= j) {

			//*a[i]が基準値より小さければ右に行く必要がないので、要素はそのままで
			//*インデックスiを1つ増やして次の値に行く
			//*同様に、a[j]が基準値より大きければ左に行く必要がないので、要素はそのままで
			//*インデックスjを1つ減らして次の値に行く
			while(a[i]<x) i++;
			while(a[j]>x) j--;

			//*外側のwhile文のテストでi<=jであっても、if文の処理によってi>=jになることがあるので、
			//*ここでも条件を付ける
			if(i<=j) {
				w = a[i];

				//*a[i]とa[j]を入れ替える
				if(a[i]>=x && a[j]<=x) {
					a[i] = a[j];
					a[j] = w;
					i++;
					j--;
				}

			}
		}


		//*再帰呼び出しを使って、分割したものをさらにsort関数に入れ、何度も繰り返すことで
		//*小さい順に並び替える
		sort(a, low, j);
		sort(a, i, high);
	}

}
