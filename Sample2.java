package task02;

public class Sample2 {
	/* この例では、配列の扱いの練習をします。
	 * コメントの指示に従って、変更や追加の作業をしながら
	 * 理解するようにしてください。
	 * ２０１８年４月１７日改訂
	 */

	public static void main(String[] args)	{
		// Javaのデータ型には、大きくわけると
		//　（１）基本データ型　と
		//　（２）それ以外のデータ型
		// があります。この区別に対応して、データを格納する
		// 変数の性格に大きな違いがあります。
		// この違いを理解することがJava 攻略の第一歩です。

		// まず、次の変数宣言を見ましょう。

		int j, k;
		double x, y;
		boolean condition;

		// int型、double型、boolean 型はすべて
		//　基本データ型です。これらのデータ型の変数は、
		//　**データを直接その中に格納します**。
		//　int 型の値は４バイト（３２ビット）で表現されるので、
		//　j, k に対してはそれぞれ４バイトの場所が割り当てられます。
		//  同様に、x, y に対してはそれぞれ８バイトの場所が割り当てられます。
		//  boolean の condition については１ビットの場所でよい理屈ですが、
		// 処理速度の問題もあるので、実装によるでしょう。

		// それ以外のデータ型は、一般にオブジェクトと呼ばれるもの
		// ですが、ここではそのなかで 配列について学びます。
		// 配列を表す Java の変数は、
		// ** 配列のある場所を指し示すためのものです**。
		// C のポインタに対応します。
		// Java では、配列（一般にはオブジェクト）の場所
		// を指し示すことを
		// ** 参照する **
		// と言い、
		// 指し示すもの（C のポインタ）を
		// ** 参照 **
		// と呼びます。
		// 繰り返しますが、Java の配列変数は、配列の実体への参照を格納するもので
		// 配列の実体そのものを表すのではありません。

		// したがって配列変数の大きさは通常では 4バイト、つまり配列実体への参照に必要な大きさであり、
		// 参照される配列がいくら大きくても、これは変わりません。

		// 下の宣言のコメントをはずして見てください。

		// int a[100];

		// Cでは許されたこの宣言がJava ではエラーになります。
		// Java では、配列を指し示す変数は宣言により確保できますが、
		// 配列の実体を宣言によって確保することはできません。
		// これを理解したら、上の宣言をふたたびコメントアウトしてください。
		// コメントアウトとは、コメントに変えてプログラムの要素でなくす
		// ことを言います。

		// 正しい宣言は

		int[] a;

		// または

		int b[];

		// です。
		// くり返しますが、この時点では、配列を指し示すための
		// 変数 a, b が確保されただけで、配列の実体はありません。
		// a と b の値は　null (何も指していないことを表す値、
		// C における NULL に対応する）です。
		//

		// 配列の実体をつくり出すには、new 演算子を用います。
		// このとき、配列の大きさを指定する必要があります。
		// たとえば、大きさ 3 の int型配列をつくり、a がそれを指すように
		// するには、次のようにします。

		a = new int[3];

    // いくつかの補足をします。

		// （１）new 演算子は C のmalloc 関数に対応し、実行時に
		// メモリの確保をします。
		// （２）作られた配列の実体そのものには名前がありません。
		// 現在は、a という変数から参照されることにより、アクセスが可能
		// になっています。これは、C によって動的に確保された配列と
		// 同じ事情です。
		// （３）C で、int a[3] と宣言された配列の場合には、
		// 確保された３要素の配列自体に a という名前がついています。
		// この違いをはっきりと意識しましょう。

		// 配列変数の宣言と、配列の実体の確保をあわせて

		int[] a1 = new int[10];

		// のように書くこともできます。

		// 以上を理解すれば、次の代入で何が起きるか理解できるでしょう。
    // 第2回提出のコメントでは、この代入で何がおきるかを説明してください。
	//*aは、大きさ3のint型配列を指している。
	//*そのため、次の代入を行うことによって、bも大きさ3のint型配列を指すようになる

		b = a;

		// 配列要素の指定は、C言語 と同様に書けます。

		a[0] = 1;
		a[1] = a[0] * 2;
		a[2] = a[0] + a[1];

		// 少し練習しましょう。
		// 新しい、大きさ 10 の配列オブジェクトを生成（確保）して、
		// 変数c がそれを
		// 参照するようにしてください。

		/* 記入コード（１）*/
		int c[];
		c = new int[10];

		//*記入コード1では、まず配列を指し示す配列を宣言し、
		//*大きさ10のint型配列を示すようにする

		// この時点で、変数 a, b, c　のどれもが配列の実体を指すようになりました。
		// for 文を使って、これらの配列の要素に値を入れてみましょう。
		// aの指す配列に対するfor文の例を示します。

		for (int i = 0; i < 3; i++)
			a[i] = i;

		// 同様に、 b の指す配列の、第 i 要素　（0 <= i < 3)に、２ * i を
		// 代入してください。

		/* 記入コード（２）*/
		for(int i = 0; i < 3; i++)
			b[i] = 2*i;
		//*bの指し示す配列の0番目から2番目までのそれぞれの要素に、2*iを
		//*代入している

		// 同様に、 c の指す配列の、第 i 要素　（0 <= i < 10)に、3 * i を
		// 代入してください。

		/* 記入コード（3）*/
		for(int i = 0; i < 10; i++)
			c[i] = 3*i;
		//*同様に、cの指し示す配列の0番目から10番目までのそれぞれの要素に、3*iを
		//*代入している

		//結果を確認してみましょう。 ３番目の for 文のなかで、
		// c[i] という配列の参照は、記入コード（１）を正しく記入するまでは
		// コンパイルエラーになります。

    // 第2回提出のコメントでは、この出力結果を分析して、なぜそうなるかを説明してください。
		// 特に、aの要素の出力結果に注意をはらってください。

		//*107行目でb=aと記述したため、配列aとbは同じ配列の場所を指している
		//*そのため上記のfor文で、aに要素を入れた後にbに要素を入れたため
		//*配列自体の要素が上書きされている
		//*その後、下記でaの指す配列を出力する時に、上書きされた、bと同じ配列の要素が出力されている、

		System.out.println("a = ");
		for (int i = 0; i < 3; i++)
			System.out.println(a[i]);
		System.out.println("b = ");
		for (int i = 0; i < 3; i++)
			System.out.println(b[i]);
		System.out.println("c = ");

		// cの参照する配列の要素をすべて（10個）プリントするfor文を書いてください。
    /* 記入コード（４）*/
		for(int i = 0; i < 10; i++)
			System.out.println(c[i]);

	//*cの指す配列の要素を、iが0から9になるまで(すべて)出力している

		//
		// メソッドの引数における配列の扱いは
		// C の関数の場合とほぼ同じです。
		// sum は、配列の要素の総和を求める関数です。
    // 下にあるメソッド sum の宣言を完成した上で実行して
    // 結果があっているか確認してください。

    // 第2回提出のコメントでは、この出力結果を分析して、
    // どうしてそういう出力になるかを説明してください。

	//*下記にあるメゾットsumで、配列の要素の総和を求めている
	//*そのメゾットを、ｃ言語でいう関数のように、printlnの中で呼び出して出力している

		System.out.println("sum of a = " + sum(a));
		System.out.println("sum of b = " + sum(b));
		/* 記入コード（５）：　同様に配列cの要素の合計をプリントする*/
		System.out.println("sum of c = " + sum(c));
		//*配列cの要素の総和を出力している

		// 最後に、配列変数の宣言、配列実体の生成、配列要素の初期化のすべてを同時に行う方法を
		// 示します。

		int[] d = {5, 6, 7, 8, 9, 10, 11, 12};

		// 右辺では、指定された要素を持った大きさ８のint型配列が生成されます。

		// 結果を表示します。
    // ここで、d.length は d の参照する配列の長さを表す変数です。

    // 第2回提出のコメントでは、この出力結果を分析して、
    // どうしてそういう出力になるかを説明してください。

	//*d.lengthはdの参照する配列の長さを表す変数であるため、
	//*ここでは大きさ8の配列を出力するということになり、for文によって
	//*それぞれの要素を出力している

		System.out.println("d = ");
		for (int i = 0; i < d.length; i++)
			System.out.println(i + ":" + d[i]);
	}

	// 配列要素の総和を求めるメソッドです。
	// main メソッドから呼ぶ場合は、static 修飾子をつけます。
	// 他のクラスから呼ぶ必要がないので、private 修飾子をつけます。
	// 宣言の場所は、mainメソッドの前でも後でも構いません。

	private static int sum(int[] a) {
		int s = 0;
		// 総和を求める for 文を書いてください。
		// Javaでは配列そのものが、大きさ（要素数）の
		// 情報を持っています。配列 a の大きさは
		// a.length によって見ることができます。
		/* 記入コード（６）*/
		for(int i = 0; i < a.length; i++)
			s = s + a[i];

		return s;
	}
}
